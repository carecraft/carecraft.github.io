---
layout: post
title: PID位图算法
category : basictheory/linux_kernel
tagline:
tags : [pid, linux]
---
{% include JB/setup %}

<item>

<content:encoded>

内核分配进程pid的接口被定义在<a href="http://lxr.free-electrons.com/source/kernel/pid.c#L297">kernel/pid.c</a>文件中。

<pre><code>297 struct pid *alloc_pid(struct pid_namespace *ns)
298 {
299         struct pid *pid;
300         enum pid_type type;
301         int i, nr;
302         struct pid_namespace *tmp;
303         struct upid *upid;
304         int retval = -ENOMEM;
305
306         pid = kmem_cache_alloc(ns-&gt;pid_cachep, GFP_KERNEL);
307         if (!pid)
308                 return ERR_PTR(retval);
309
310         tmp = ns;
311         pid-&gt;level = ns-&gt;level;
312         for (i = ns-&gt;level; i &gt;= 0; i--) {
313                 nr = alloc_pidmap(tmp);
314                 if (nr &lt; 0) {
315                         retval = nr;
316                         goto out_free;
317                 }
318
319                 pid-&gt;numbers[i].nr = nr;
320                 pid-&gt;numbers[i].ns = tmp;
321                 tmp = tmp-&gt;parent;
322         }
323
324         if (unlikely(is_child_reaper(pid))) {
325                 if (pid_ns_prepare_proc(ns))
326                         goto out_free;
327         }
328
329         get_pid_ns(ns);
330         atomic_set(&amp;pid-&gt;count, 1);
331         for (type = 0; type &lt; PIDTYPE_MAX; ++type)
332                 INIT_HLIST_HEAD(&amp;pid-&gt;tasks[type]);
333
334         upid = pid-&gt;numbers + ns-&gt;level;
335         spin_lock_irq(&amp;pidmap_lock);
336         if (!(ns-&gt;nr_hashed &amp; PIDNS_HASH_ADDING))
337                 goto out_unlock;
338         for ( ; upid &gt;= pid-&gt;numbers; --upid) {
339                 hlist_add_head_rcu(&amp;upid-&gt;pid_chain,
340                                 &amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);
341                 upid-&gt;ns-&gt;nr_hashed++;
342         }
343         spin_unlock_irq(&amp;pidmap_lock);
344
345         return pid;
346
347 out_unlock:
348         spin_unlock_irq(&amp;pidmap_lock);
349         put_pid_ns(ns);
350
351 out_free:
352         while (++i &lt;= ns-&gt;level)
353                 free_pidmap(pid-&gt;numbers + i);
354
355         kmem_cache_free(ns-&gt;pid_cachep, pid);
356         return ERR_PTR(retval);
357 }
</code></pre>
</content:encoded>

</item>
