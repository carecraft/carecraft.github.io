---
layout: post
title: 设计原则
category : designpattern
author: Max
tags : [design patterns, principle]
---


## 1. 单一职责原则（Single Responsibility Principle）

>单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。

软件设计真正要做的许多内容，就是发现职责并将其相互分离。如果一个类承担的职责过多，就等于把这些
职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。

单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。

## 2. 开放-封闭原则（Open Close Principle）

>开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

即对于扩展是开放的，对于更改是封闭的。

事实上，无论模块多么封闭，总会存在一些无法对之封闭的东西。猜出最有可能发生的变化种类，然后
构造抽象将其隔离，就是设计需要做出的思考。

最初写代码时，假设变化不会发生；当变化发生时，将创建抽象来隔离之后发生的同类变化。面对需求，
通过增加新的代码而非更改现有代码来改变程序。

## 3. 里氏替换原则（Liskov Substitution Principle）

>里氏替换原则，子类型必须能够替换掉它们的父类型。

一个软件实体如果使用的是一个父类的话，那其一定适用于子类，且程序行为没有变化。

通俗的来讲，子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，
但不能覆盖父类的非抽象方法；当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）
要比父类方法的输入参数更宽松；当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的
返回值）要比父类更严格。

## 4. 依赖倒置原则（Dependence Inversion Principle）

>A. 高层模块不应该依赖低层模块，两个都应该依赖抽象。

>B. 抽象不应该依赖细节，细节应该依赖抽象。

传递依赖关系有三种方式，接口传递、构造方法传递和setter方法传递。实际编程中，我们需要做到
低层模块尽量都有抽象类或接口，或者两者都有；变量的声明类型尽量是抽象类或接口；使用继承时
遵循里氏替换原则。

依赖倒置原则说白了，就是要针对接口编程，而不要针对实现编程。

依赖倒转可以说是面向对象设计的标志，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，
即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之则是面向过程的设
计了。

## 5. 迪米特法则（Law Of Demeter）

>迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中
一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

迪米特法则强调了类之间的松耦合，每一个类都应当尽量降低成员的访问权限。

## 6. 接口隔离原则（Interface Segregation Principle）

>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

采用接口隔离原则对接口进行约束时，要注意以下几点：

* 接口尽量小，但要有限度。

  对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。

* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，隐藏不需要的。

  只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

* 提高内聚，减少对外交互。

  使接口用最少的方法去完成最多的事情。

## 参考

1. [designpattern六大原则-mile的博客](http://www.cnblogs.com/lhws/archive/2012/03/10/2389189.html)
