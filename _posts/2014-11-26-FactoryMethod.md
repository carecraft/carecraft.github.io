---
layout: post
title: 工厂方法模式
category : design patterns
tagline:
tags : [design patterns, factory method]
---
{% include JB/setup %}

## 定义

《大话设计模式》：

>工厂方法模式，定义一个用于创建对象的接口，让子类实现实例化哪一个类。工厂方法使一个类的
实例化延迟到子类。[DP]

与简单工厂模式相同，是创建类模式。工厂方法的主要功能是让父类在不知道具体实现的情况下，
完成自身的功能调用，而具体的实现延迟到子类。

工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现产品，选择判断的问题依然存在，也
就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。想要加功能，就去修改客户
端。

区别于简单工厂模式，工厂方法模式更符合开闭原则。

## UML类图

![工厂方法模式结构图](http://www.uml.org.cn/sjms/images/2010061806555982.gif)

该模式中包含的角色及其职责如下：

* 抽象工厂（Creator）

  工厂方法模式的核心，声明工厂方法，返回一个Product类型的对象。

* 具体工厂（ConcreteCreator）

  重定义工厂方法以返回一个ConcreteProduct实例，是实现抽象工厂接口的具体工厂类，包含与应
  用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。

* 抽象产品（Product）

  定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。

* 具体产品（ConcreteProduct）

  具体的产品，实现了Product接口。

## 特点

首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具
体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛
过程，减少模块间的耦合。

其次，工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类
或扩展一个工厂类，就可以完成“拥抱变化”,Creator不用做任何修改。

再次，屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需
要关心产品的接口，只要接口保持不表，系统中的上层模块就不要发生变化，因为产品类的实例
化工作是由工厂类负责，一个产品对象具体由哪一个产品生成是由工厂类决定的。

最后，工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不
用关心，符合迪米特原则，不需要的就不要去交流；也符合依赖倒转原则，只依赖产品类的抽象；
当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！

## 参考

1. [工厂方法模式-百度百科](http://baike.baidu.com/view/1580263.htm?fr=aladdin)

2. [工厂方法模式-技术之大，在乎你我心中](http://www.cnblogs.com/cbf4life/archive/2009/12/20/1628494.html)
